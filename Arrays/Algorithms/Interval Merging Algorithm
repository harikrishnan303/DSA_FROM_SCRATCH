note down the first interval as prev
0th is considered as start
1st is considered as end.

then compare the next first with prev's first if first greater change the prev's 1
else add to the list and change prev to the next.


class Solution {
    public int[][] merge(int[][] intervals) 
    {

        int n=intervals.length;
        if (intervals == null || intervals.length == 0)
        return new int[0][0];

        Arrays.sort(intervals,(a,b)->Integer.compare(a[0],b[0]));
        List<int[]>merged=new ArrayList<>();
        int prev[]=intervals[0];

        for(int i=1;i<n;i++)
        {
            int interval[]=intervals[i];
            if(interval[0]<=prev[1])
            {
                prev[1]=Math.max(interval[1],prev[1]);
            }
            else
            {
                merged.add(prev);
                prev=interval;
            }
        }
        merged.add(prev);

        return merged.toArray(new int[merged.size()][]);

        
    }
}

Time Complexity:O(N)
Space Complexity:O(N)